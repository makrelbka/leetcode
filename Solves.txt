ALGORITHMS

1/ Оставное дерево графа - задаем граф в виде вершина : дети, делаем DFS по графу и при попадание в уже посещенную вершину разрываем ребро 

2/ Количество компонент связности графа - задаем граф в виде вершина : дети, идем по вершинам и если еще не посещена запускаем DFS, таким образом первый DFS отметит вершины первой компоненты как посещенные и таким образом следующая итерация цикла будет из вершины не принадлежащей первой компоненте связности

3/  Цикл в ориентированном графе - задаем граф в виде вершина : дети,  потом запускаем n DFS от каждой вершины, на каждой итерации для каждой вершины храним родителя, как только попадем в посещенную разматываем через родителей путь пока не попадем в повторяющуюся вершину - это и будет циклом 

4/ Раскраска графа в 2 цвета - задаем граф в виде вершина : дети, запускаем цикл по вершинам для каждой не посещенной идем BFS по графу и просто раскрашиваем в разные цветы соседние. 

5/ BFS - берем очередь кладем в нее первый элемент дерева, теперь пока очередь не пуста достаем оттуда элемент и кладем в очередь его детей (в графе нужен массив посещенных чтоб не зациклиться)

6/ DFS - запускаем DFS от старта потом для каждого ребенка старта запускаем DFS и так до низа дерева ( в графе нужен массив посещенных чтоб не зациклиться)

7/ Топологическая сортировка ориентированного графа графа (TopSort) - задаем граф в виде вершина : дети и массив где по номеру вершины получаем кол-во вхождений в нее, далее создаем очередь и заполняем ее вершинами с 0 вхождений, далее идем циклом пока очередь не пуста, на каждой итерации берем элемент из очереди и проходимся по его соседям вычитая кол-во вхождений в соседа на 1 и если после этого кол-во вхождений в соседа стало = 0 добавляем этого ребенка в очередь

LEETCODE

z8/ Находим кол-во элементов которые нужно пройти чтобы с первого ряда вернуться в первый ряд (step) . Заводим массив значений для каждого ряда. И теперь при прохождении первой половины step кладем по индексу а при прохождении второй по step - индексу. И потом собираем строки из массива в одну большую строку 

z1004/ Нахождение максимальной подпоследовательности массива состоящей из единиц с возможностью заменить k нулей на 1: Заводим два указателя на начало и конец и теперь если еще можно менять 0 на 1 то двигаем конец и если встретили 0 уменьшаем k на 1, когда k == 0 начинаем двигать левую пока не встретим 0 и тем самым не вернем себе одну замену то есть k++ 

z88/ Если надо смеджить два отсортированных массива в один отсортированный, то берем три индекса для первого второго и итогового массива. Теперь идем либо с концов массивов либо с начала и сравниваем элементы по индексам, берем тот который подходит нам по реализации и увеличиваем индекс по которому его получили на 1.
То есть если есть [1, 2, 3] [3, 7]. То мы возьмем как начальные 1 и 3 так как 1 меньше добавим его и теперь будем смотреть на 2 и 3 в соответсвующих массивах и так далее мы получим новый отсорченный.

z1493/ Longest Subarray of 1's After Deleting One Element:
Идем двумя указателями
Двигаем правый пока встречаем 1 или 0 при условие что 0 встречался 1 раз
Когда не можем двигать правый начинаем двигать левый пока не встретим 0, тем самым убрав встретившийся ноль и получив возможность двигатьь правый

z228/ Summary ranges
Идем по массиву и обновляем 3 переменные старт конец и предыдущий 
Если предыдущий отличется на 1 то обновляем конец, иначе записываем отрезок и обновлем начало

z443/ String Compression
Будем идти по массиву
Если будет встречать тот же символ что и предыдущий то увеличиваем счетчик
Иначе будем записывать в результат предыдущий символ и счетчик (если он больше 1)(записываем через for так как каждый элемент должен быть числом), и обнулять счетчик 

z125/ Valide Palindrome
Идем двумя указателями от начала и конца строки
Если символ не буква или цифра то пропускаем его
Если символы не равны то возвращаем False
Если все символы равны то возвращаем True

z49/ Group Anagrams
Идем по списку слов
В каждое слово сортируем чтобы использовать как ключ 
По полученному ключу кладем в мапу слово 
Тем самым слова состоящие из одних букв будут класться по одному ключу 

z380/ Insert Delete GetRandom O(1)
Заводим массив для значений и мапу значения в индекс массива 
По мапе проверяем наличие и получаем индекс 
По массиву получаем рандомный элемент
Вставляем элемент просто через ключ в мапу и в конце массива 
А удаляем из массива и мапы таим образом:
Убираем ненужный элемент в конец массива и мапы и затем удаляем 
А на его место ставим последний, тем самым не сбиваем индексы

z993/ Number Of Recent Calls
Заводим массив и перерменную указывающую на начало списка 
Теперь при каждом добавлении элемента будем двигать старт до момента пока разница не станет меньше 3000
И выводим число элментов от старта до конца

z101/ Symmetric Tree
Идем по дереву
Берем левое и правое и отправляем в функцию, 
В функции проверяем на то что вершины симметричны если мы внизу, иначе запускаем дальше для детей и сравнниваем значения в которые уже пришли

z3/ Longest Substring Without Repeating Characters
Идем по строчке двумя указателями 
Используем мапу для хранения индексов символов и проверки на наличие символов
Если, встретили символ,который уже был после левой границы то двигаем левую границу 
Иначе, обновляем максимальную длину

z567/ Permutation in String
Нам нужен сет встречающихся букв, чтобы проверять есть ли буква в нужно нам строке
Нам нужна мапа для подсчета вхождений букв 
И два указателя для движения по строке 
Сначала пройдемся по строке один, собрав мапу для необходимых букв 
И сет для вхождений получим из первой строки 
Далее пойдем по второй и если будем встречать нужную букву правым указателем то уменьшаем ее количество в мапе, если левым то увелчим
Если значение в мапе стало 0, удалим элемент (можно заменить на счетчик)
И если мапа пустая, значит все буквы из первой строки есть во второй и в нужном количестве

z1446/ Consecutive Characters
Идем двумя указателями по строке
Двигаем правый пока значение по нему равно значению по левому
В ином случае обновляем максимум и передиваем левый указатель к правому 

z849/ Maximize Distance to Closest Person:
Идем сначала ищем максимумальную последовательность из нулей, найденный результат поделим на 2 чтобы найти расстояние до ближайшего
Теперь отдельно посмотрим на последнюю итерацию, ее не надо делить на 2 так как человек может сесть скраю
И запустим алгоритм еще раз, чтобы посмотреть такой же случай если человек сядет с краю в начале 

z350/ Intersection of Two Arrays II
Сортируем оба массива 
Идем указателем по каждому из массивов
Если элементы равны то записывем в массив результата этот элемент и увеличиваем оба указателя
Иначе увеличиваем указатель того массива чей элемент меньше 