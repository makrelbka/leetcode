ALGORITHMS

1/ Оставное дерево графа - задаем граф в виде вершина : дети, делаем DFS по графу и при попадание в уже посещенную вершину разрываем ребро 

2/ Количество компонент связности графа - задаем граф в виде вершина : дети, идем по вершинам и если еще не посещена запускаем DFS, таким образом первый DFS отметит вершины первой компоненты как посещенные и таким образом следующая итерация цикла будет из вершины не принадлежащей первой компоненте связности

3/  Цикл в ориентированном графе - задаем граф в виде вершина : дети,  потом запускаем n DFS от каждой вершины, на каждой итерации для каждой вершины храним родителя, как только попадем в посещенную разматываем через родителей путь пока не попадем в повторяющуюся вершину - это и будет циклом 

4/ Раскраска графа в 2 цвета - задаем граф в виде вершина : дети, запускаем цикл по вершинам для каждой не посещенной идем BFS по графу и просто раскрашиваем в разные цветы соседние. 

5/ BFS - берем очередь кладем в нее первый элемент дерева, теперь пока очередь не пуста достаем оттуда элемент и кладем в очередь его детей (в графе нужен массив посещенных чтоб не зациклиться)

6/ DFS - запускаем DFS от старта потом для каждого ребенка старта запускаем DFS и так до низа дерева ( в графе нужен массив посещенных чтоб не зациклиться)

7/ Топологическая сортировка ориентированного графа графа (TopSort) - задаем граф в виде вершина : дети и массив где по номеру вершины получаем кол-во вхождений в нее, далее создаем очередь и заполняем ее вершинами с 0 вхождений, далее идем циклом пока очередь не пуста, на каждой итерации берем элемент из очереди и проходимся по его соседям вычитая кол-во вхождений в соседа на 1 и если после этого кол-во вхождений в соседа стало = 0 добавляем этого ребенка в очередь

LEETCODE

z8/ Находим кол-во элементов которые нужно пройти чтобы с первого ряда вернуться в первый ряд (step) . Заводим массив значений для каждого ряда. И теперь при прохождении первой половины step кладем по индексу а при прохождении второй по step - индексу. И потом собираем строки из массива в одну большую строку 

z1004/ Нахождение максимальной подпоследовательности массива состоящей из единиц с возможностью заменить k нулей на 1: Заводим два указателя на начало и конец и теперь если еще можно менять 0 на 1 то двигаем конец и если встретили 0 уменьшаем k на 1, когда k == 0 начинаем двигать левую пока не встретим 0 и тем самым не вернем себе одну замену то есть k++ 

z88/ Если надо смеджить два отсортированных массива в один отсортированный, то берем три индекса для первого второго и итогового массива. Теперь идем либо с концов массивов либо с начала и сравниваем элементы по индексам, берем тот который подходит нам по реализации и увеличиваем индекс по которому его получили на 1.
То есть если есть [1, 2, 3] [3, 7]. То мы возьмем как начальные 1 и 3 так как 1 меньше добавим его и теперь будем смотреть на 2 и 3 в соответсвующих массивах и так далее мы получим новый отсорченный.

z1493/ Longest Subarray of 1's After Deleting One Element:
Идем двумя указателями
Двигаем правый пока встречаем 1 или 0 при условие что 0 встречался 1 раз
Когда не можем двигать правый начинаем двигать левый пока не встретим 0, тем самым убрав встретившийся ноль и получив возможность двигатьь правый

z228/ Summary ranges
Идем по массиву и обновляем 3 переменные старт конец и предыдущий 
Если предыдущий отличется на 1 то обновляем конец, иначе записываем отрезок и обновлем начало

z443/ String Compression
Будем идти по массиву
Если будет встречать тот же символ что и предыдущий то увеличиваем счетчик
Иначе будем записывать в результат предыдущий символ и счетчик (если он больше 1)(записываем через for так как каждый элемент должен быть числом), и обнулять счетчик 


